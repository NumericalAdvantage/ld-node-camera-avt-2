// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GENERICMATRIX3D_LINK_DEV_H_
#define FLATBUFFERS_GENERATED_GENERICMATRIX3D_LINK_DEV_H_

#include "flatbuffers/flatbuffers.h"

namespace link_dev {

struct GenericMatrix3D;
struct GenericMatrix3DT;

enum MatrixScalarType {
  MatrixScalarType_NotSpecified = 0,
  MatrixScalarType_Float = 1,
  MatrixScalarType_Double = 2,
  MatrixScalarType_Int8 = 3,
  MatrixScalarType_Int16 = 4,
  MatrixScalarType_Int32 = 5,
  MatrixScalarType_Int64 = 6,
  MatrixScalarType_UInt8 = 7,
  MatrixScalarType_UInt16 = 8,
  MatrixScalarType_UInt32 = 9,
  MatrixScalarType_UInt64 = 10,
  MatrixScalarType_MIN = MatrixScalarType_NotSpecified,
  MatrixScalarType_MAX = MatrixScalarType_UInt64
};

inline const MatrixScalarType (&EnumValuesMatrixScalarType())[11] {
  static const MatrixScalarType values[] = {
    MatrixScalarType_NotSpecified,
    MatrixScalarType_Float,
    MatrixScalarType_Double,
    MatrixScalarType_Int8,
    MatrixScalarType_Int16,
    MatrixScalarType_Int32,
    MatrixScalarType_Int64,
    MatrixScalarType_UInt8,
    MatrixScalarType_UInt16,
    MatrixScalarType_UInt32,
    MatrixScalarType_UInt64
  };
  return values;
}

inline const char * const *EnumNamesMatrixScalarType() {
  static const char * const names[] = {
    "NotSpecified",
    "Float",
    "Double",
    "Int8",
    "Int16",
    "Int32",
    "Int64",
    "UInt8",
    "UInt16",
    "UInt32",
    "UInt64",
    nullptr
  };
  return names;
}

inline const char *EnumNameMatrixScalarType(MatrixScalarType e) {
  if (e < MatrixScalarType_NotSpecified || e > MatrixScalarType_UInt64) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMatrixScalarType()[index];
}

enum StorageOrderType {
  StorageOrderType_ColumnMajor = 0,
  StorageOrderType_RowMajor = 1,
  StorageOrderType_MIN = StorageOrderType_ColumnMajor,
  StorageOrderType_MAX = StorageOrderType_RowMajor
};

inline const StorageOrderType (&EnumValuesStorageOrderType())[2] {
  static const StorageOrderType values[] = {
    StorageOrderType_ColumnMajor,
    StorageOrderType_RowMajor
  };
  return values;
}

inline const char * const *EnumNamesStorageOrderType() {
  static const char * const names[] = {
    "ColumnMajor",
    "RowMajor",
    nullptr
  };
  return names;
}

inline const char *EnumNameStorageOrderType(StorageOrderType e) {
  if (e < StorageOrderType_ColumnMajor || e > StorageOrderType_RowMajor) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStorageOrderType()[index];
}

struct GenericMatrix3DT : public flatbuffers::NativeTable {
  typedef GenericMatrix3D TableType;
  uint32_t rows;
  uint32_t cols;
  uint32_t depth;
  MatrixScalarType scalar_type;
  StorageOrderType storage_order;
  std::vector<uint8_t> data_bytes;
  GenericMatrix3DT()
      : rows(0),
        cols(0),
        depth(0),
        scalar_type(MatrixScalarType_NotSpecified),
        storage_order(StorageOrderType_ColumnMajor) {
  }
};

struct GenericMatrix3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GenericMatrix3DT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DEPTH = 8,
    VT_SCALAR_TYPE = 10,
    VT_STORAGE_ORDER = 12,
    VT_DATA_BYTES = 14
  };
  uint32_t rows() const {
    return GetField<uint32_t>(VT_ROWS, 0);
  }
  uint32_t cols() const {
    return GetField<uint32_t>(VT_COLS, 0);
  }
  uint32_t depth() const {
    return GetField<uint32_t>(VT_DEPTH, 0);
  }
  MatrixScalarType scalar_type() const {
    return static_cast<MatrixScalarType>(GetField<uint8_t>(VT_SCALAR_TYPE, 0));
  }
  StorageOrderType storage_order() const {
    return static_cast<StorageOrderType>(GetField<uint8_t>(VT_STORAGE_ORDER, 0));
  }
  const flatbuffers::Vector<uint8_t> *data_bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_BYTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ROWS) &&
           VerifyField<uint32_t>(verifier, VT_COLS) &&
           VerifyField<uint32_t>(verifier, VT_DEPTH) &&
           VerifyField<uint8_t>(verifier, VT_SCALAR_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_STORAGE_ORDER) &&
           VerifyOffset(verifier, VT_DATA_BYTES) &&
           verifier.VerifyVector(data_bytes()) &&
           verifier.EndTable();
  }
  GenericMatrix3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GenericMatrix3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GenericMatrix3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GenericMatrix3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GenericMatrix3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rows(uint32_t rows) {
    fbb_.AddElement<uint32_t>(GenericMatrix3D::VT_ROWS, rows, 0);
  }
  void add_cols(uint32_t cols) {
    fbb_.AddElement<uint32_t>(GenericMatrix3D::VT_COLS, cols, 0);
  }
  void add_depth(uint32_t depth) {
    fbb_.AddElement<uint32_t>(GenericMatrix3D::VT_DEPTH, depth, 0);
  }
  void add_scalar_type(MatrixScalarType scalar_type) {
    fbb_.AddElement<uint8_t>(GenericMatrix3D::VT_SCALAR_TYPE, static_cast<uint8_t>(scalar_type), 0);
  }
  void add_storage_order(StorageOrderType storage_order) {
    fbb_.AddElement<uint8_t>(GenericMatrix3D::VT_STORAGE_ORDER, static_cast<uint8_t>(storage_order), 0);
  }
  void add_data_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_bytes) {
    fbb_.AddOffset(GenericMatrix3D::VT_DATA_BYTES, data_bytes);
  }
  explicit GenericMatrix3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GenericMatrix3DBuilder &operator=(const GenericMatrix3DBuilder &);
  flatbuffers::Offset<GenericMatrix3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GenericMatrix3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<GenericMatrix3D> CreateGenericMatrix3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t rows = 0,
    uint32_t cols = 0,
    uint32_t depth = 0,
    MatrixScalarType scalar_type = MatrixScalarType_NotSpecified,
    StorageOrderType storage_order = StorageOrderType_ColumnMajor,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_bytes = 0) {
  GenericMatrix3DBuilder builder_(_fbb);
  builder_.add_data_bytes(data_bytes);
  builder_.add_depth(depth);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  builder_.add_storage_order(storage_order);
  builder_.add_scalar_type(scalar_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GenericMatrix3D> CreateGenericMatrix3DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t rows = 0,
    uint32_t cols = 0,
    uint32_t depth = 0,
    MatrixScalarType scalar_type = MatrixScalarType_NotSpecified,
    StorageOrderType storage_order = StorageOrderType_ColumnMajor,
    const std::vector<uint8_t> *data_bytes = nullptr) {
  auto data_bytes__ = data_bytes ? _fbb.CreateVector<uint8_t>(*data_bytes) : 0;
  return link_dev::CreateGenericMatrix3D(
      _fbb,
      rows,
      cols,
      depth,
      scalar_type,
      storage_order,
      data_bytes__);
}

flatbuffers::Offset<GenericMatrix3D> CreateGenericMatrix3D(flatbuffers::FlatBufferBuilder &_fbb, const GenericMatrix3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GenericMatrix3DT *GenericMatrix3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GenericMatrix3DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GenericMatrix3D::UnPackTo(GenericMatrix3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rows(); _o->rows = _e; };
  { auto _e = cols(); _o->cols = _e; };
  { auto _e = depth(); _o->depth = _e; };
  { auto _e = scalar_type(); _o->scalar_type = _e; };
  { auto _e = storage_order(); _o->storage_order = _e; };
  { auto _e = data_bytes(); if (_e) { _o->data_bytes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data_bytes[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<GenericMatrix3D> GenericMatrix3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GenericMatrix3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGenericMatrix3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GenericMatrix3D> CreateGenericMatrix3D(flatbuffers::FlatBufferBuilder &_fbb, const GenericMatrix3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GenericMatrix3DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rows = _o->rows;
  auto _cols = _o->cols;
  auto _depth = _o->depth;
  auto _scalar_type = _o->scalar_type;
  auto _storage_order = _o->storage_order;
  auto _data_bytes = _o->data_bytes.size() ? _fbb.CreateVector(_o->data_bytes) : 0;
  return link_dev::CreateGenericMatrix3D(
      _fbb,
      _rows,
      _cols,
      _depth,
      _scalar_type,
      _storage_order,
      _data_bytes);
}

}  // namespace link_dev

#endif  // FLATBUFFERS_GENERATED_GENERICMATRIX3D_LINK_DEV_H_
